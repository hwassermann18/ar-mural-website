{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to AR Mural","text":""},{"location":"about/","title":"Modo me delubraque haec iunctissimus genas decus","text":""},{"location":"about/#in-credula-nepheleque-fundit","title":"In credula Nepheleque fundit","text":"<p>Lorem markdownum simul nullisque letale prosiliunt fila arbore: meminisse committit pectora posse me. Obiecit membra! Quisquis oris nescio iter non verba tenebat non ubi, arbor sedibus rustica murmura! Tendi erat praebuit infelix laborum lilia vertice admonitu: medio.</p> <ul> <li>Vestes per oro Thestiadae cruorem semper</li> <li>In detulit altera generosior securus Cereris</li> <li>Contemne manuque</li> <li>Super Cinyran</li> <li>Fugit esse narratur in auctor domus quod</li> </ul>"},{"location":"about/#et-discite-fama","title":"Et discite fama","text":"<p>Sanguine in exspectatum nomine, ipsa in fasque ossa; galeae. Meritisne hanc suspiratibus illi ut inque secreta positi: Lycabas Armeniae.</p> <p>Et tu emisit quodcumque sive spelunca fronde quod sensurus intercipe, planxitque India perpessae! Luce Agamemnona vicimus, obvia, nocti inter accipiter quodque taxo magnique ossibus nec vincat multum, suos. Manus in taedia turribus cessent nuda: Tagus membris multa latus. Aquaticus in flammas periuria accipitris arce perpetuo pontus, et aut. Tulisti sequente ratis fidissima eundem discrimine et metus absens?</p>"},{"location":"about/#est-corpore-mora-armenta","title":"Est corpore mora armenta","text":"<p>Verso ante: iuves quem ignaram in laeta, sed et ferrum equas. Haesit corpore turba singultantem hora reticere bis hasta terramque passim nefas duorum nivea iuncti! Tanto vitta posita vidit quatiebant refert aves anili astu terra reddebant, Bienoris fratrique ipsum.</p> <p>Cervice sermone. Ita bos superamur pleno amore illo caecus animam sicca erat adspicias amantibus in mihi campi et gerens pulsarunt Hyanteo. Sua orbem si dives, captus inscius est videri Nile vasto. Ostendit labens.</p> <p>Formosior profugi edentem et vacuum silent nata; salutem Nil arma auro puellari. Decimum pulchrosque aut classe, tenebo fessa vincant simul victor thyrsos telum.</p>"},{"location":"controls/","title":"Controls","text":""},{"location":"controls/#controls","title":"Controls","text":"<p>It will be useful to first learn how the controls for using the tools in augmented reality and how that translates to running a playbox simulation in Unity.</p>"},{"location":"controls/#hand-controls-in-hololens","title":"Hand Controls in HoloLens","text":""},{"location":"controls/#keyboard-controls-in-unity-simulation","title":"Keyboard Controls in Unity Simulation","text":"<p>For the a full description of the native key bindings, visit the MRTK input simulation website.</p>"},{"location":"intro/","title":"Introduction","text":"<p>Another goal of the 2026 AR Mural team was to improve documentation. AR Mural is one of the longest running WINLAB summer projects, so creating accurate and concise documentation would make the onboarding process much easier. Trying to learn how all the files work themselves and together can be overwhelming at first, especially if you have limited unity experience. We will introduce you to the different file types in the project and how they fit together to create AR Mural. </p>"},{"location":"intro/#general-project-folder-structure","title":"General Project Folder Structure","text":"<p>In the ar-mural-summer-2025 project folder you'll see many different folders. Lets break them down:</p> <ol> <li> <p>Assets: Core folder where all your project files live. This includes:</p> <ul> <li>Scenes: Contains .unity scene files, which define different environments. For our case we will really only use our 'main' scene.</li> <li> <p>Scripts: Houses C# scrips that control behavior. This is all of the logic behind our drawing tools.</p> <ul> <li>Inside this folder we have </li> <li>Notice also that for every C# script there is a corresponding meta file. Unity creates .meta files for every asset in the Assets folder. These files track assets using unique GUIDS, ensuring references remain intact even if files are moved or renamed. Losing them can cause missing assets and project inconsistencies.</li> </ul> </li> <li> <p>Prefabs: Stores reusable game objects.</p> </li> <li>Materials &amp; Textures: Defines visual properties and textures for objects.</li> <li>Local Objects: Uploaded objects that users can import into the scene</li> <li>MTQQnet: Folder that holds the MQTTnet library files necessary for managing a server. We will go into more detail about MQTT and how we create a server later.</li> </ul> </li> <li> <p>Packages: Manages dependencies and Unity packages used in the project</p> </li> <li>Library: A cache folder unity generates for faster loading (should not be edited)</li> <li>ProjectSettings: Stores configuration files for things like input settings and rendering.</li> <li>Temp: A temporary folder used during compilation (regenerated by Unity automatically).</li> </ol>"},{"location":"tool_scripts/","title":"Tool Scripts","text":"<p>This sections describes all the scripts in the \"Tools\" folder. Each tool enables a different type of interaction in AR. Tools are activated by pinch gestures and share a common interface. If you have any questions that arise and aren't answered in that section, feel free to search the terms of your question in the search tab on the top right to see where they come up, or check out the footnotes at the bottom.</p>"},{"location":"tool_scripts/#general-script-layout","title":"General Script Layout","text":"<p>We'll cover the basic methods and functions present in all these tools first. For our sake we will use <code>BrushTool.cs</code> as our code snippets, which will be slightly different in other tools.</p>"},{"location":"tool_scripts/#1-core-variables","title":"1. Core Variables","text":"csharp<pre><code>public static BrushTool Instance { get; private set; }\n[SerializeField] private float granularity;\nprivate bool activated;\nprivate bool isLeftHand;\nprivate float distanceLeft;\nprivate Vector3? oldPos;\nprivate List&lt;Vector3&gt; meshPoints;\npublic Transform brushParent;\n</code></pre> Variable Type Description <code>Instance</code> <code>static BrushTool</code> Singleton reference to the current <code>BrushTool</code> instance for global access. <code>granularity</code> <code>float</code> (Serialized)<sup>1</sup> Min distance (in meters) the hand must move before adding a new point; controls stroke smoothness. <code>activated</code> <code>bool</code> Whether the tool is subscribed to hand input events (prevents re-activation). <code>isLeftHand</code> <code>bool</code> Indicates which hand (left/right) is being used for drawing. <code>distanceLeft</code> <code>float</code> How far the hand must move to place the next point, based on <code>granularity</code>. <code>oldPos</code> <code>Vector3?</code><sup>2</sup> Last position where a point was placed; used to measure distance traveled. <code>meshPoints</code> <code>List&lt;Vector3&gt;</code> List of all recorded 3D points for the current stroke. <code>brushParent</code> <code>Transform</code> <sup>3</sup> Parent GameObject for all stroke objects; keeps the scene hierarchy organized."},{"location":"tool_scripts/#2-singleton-pattern","title":"2. Singleton Pattern","text":"<p>A singleton pattern ensures only one tool instance exists at runtime. This is common in Unity for tools or managers that need global access. </p> <p>csharp<pre><code>public static BrushTool Instance { get; private set; }\nprivate void Awake()\n{\n    // Enforce a singleton state pattern\n    if (Instance == null)\n    {\n        Instance = this;\n    }\n    else\n    {\n        Destroy(this);\n        return;\n    }\n}\n</code></pre> These lines of code are at the beginning of all the tool scripts and confirm that there is only one instance of the class.</p>"},{"location":"tool_scripts/#3-tool-initialization","title":"3. Tool Initialization","text":"<p>csharp<pre><code>if (enabled == true)\n{\n    enabled = false;\n}\n\nbrushParent = new GameObject(\"Brush Tool\").transform;\nbrushParent.position = Vector3.zero;\n</code></pre> The code first disables the tool by default. Line 47 creates a new empty GameObject and names it <code>\"Brush Tool\"</code>. It then stores a reference to its Transform in the variable brushParent. They then set the position for <code>brushParent</code> to (0, 0, 0).</p> <p>Why do we create a parent object for this? Since the Transform class supports parent-child hierarchy, every time the BrushTool is activated, strokes are created and added as children of a shared parent object named <code>\"Brush Tool\"</code>. We will show this happening later in the code in the line: <code>obj.transform.SetParent(brushParent);</code>.</p>"},{"location":"tool_scripts/#4-activate-and-deactivate","title":"4. Activate and Deactivate","text":"<p>Each tool script includes <code>Activate()</code> and <code>Deactivate()</code> methods to manage input subscription: csharp<pre><code>public void Activate()\n{\n    if (activated) return;\n\n    activated = true;\n    PinchManager.Instance.OnHandPinched += StartTool;\n    PinchManager.Instance.OnHandReleased += StopTool;\n}\n</code></pre> csharp<pre><code>public void Deactivate()\n{\n    if (!activated) return;\n\n    activated = false;\n    PinchManager.Instance.OnHandPinched -= StartTool;\n    PinchManager.Instance.OnHandReleased -= StopTool;\n\n    // Clean up current stroke if mid-draw\n    if (enabled)\n    {\n        enabled = false;\n        oldPos = null;\n        meshPoints = null;\n        PreviewManager.Instance.StopPreview();\n    }\n}\n</code></pre> <code>Activate()</code> connects the tool to gesture events (<code>OnHandPinched</code>, <code>OnHandReleased</code>) via <code>PinchManager</code>, allowing it to respond to hand input. <code>Deactivate()</code> unsubscribes from those events and resets the tool state.</p> <p>These methods are not called automatically. They are triggered by a manager script called <code>StateManager</code>, which ensures that only one tool is active at a time.</p>"},{"location":"tool_scripts/#5-starttool","title":"5. StartTool","text":"<p>csharp<pre><code>public void StartTool(bool isLeftHand)\n{\n    if (enabled == true)\n    {\n        return;\n    }\n\n    enabled = true;\n    this.isLeftHand = isLeftHand; \n    distanceLeft = granularity;\n    Vector3 startPos = isLeftHand ? PinchManager.Instance.LeftPosition :\n                                    PinchManager.Instance.RightPosition;\n    oldPos = startPos;\n    meshPoints = new List&lt;Vector3&gt; { startPos };\n    PreviewManager.Instance.StartPreview(startPos);\n}\n</code></pre> Called when the user pinches to begin an interaction.</p> <ul> <li>Makes the tool active and ready to track hand movement(left or right)</li> <li>Captures the current hand position as the stroke\u2019s starting point</li> <li>Initializes distance tracking for smooth point placement</li> <li>Prepares the meshPoints list that will define the stroke path</li> <li>Starts the live preview to show what the user is drawing in real time</li> </ul>"},{"location":"tool_scripts/#6-update","title":"6. Update","text":"<p>csharp<pre><code>private void Update()\n{\n    Vector3 newPos = isLeftHand ? PinchManager.Instance.LeftPosition : PinchManager.Instance.RightPosition;\n\n    if (!MathUtils.Vector3Equals(newPos, oldPos.Value))\n    {\n        PreviewManager.Instance.UpdatePreview(newPos);\n    }\n\n    float distanceTraveled = (newPos - oldPos.Value).magnitude;\n\n    if (distanceTraveled &gt;= distanceLeft)\n    {\n        ...\n        Vector3 meshPoint = MathUtils.TravelAcross(oldPos.Value, newPos, totalDistanceTracked);\n        meshPoints.Add(meshPoint);\n        PreviewManager.Instance.AddPreview(meshPoint);\n    }\n    else\n    {\n        distanceLeft -= distanceTraveled;\n    }\n\n    oldPos = newPos;\n}\n</code></pre> Runs every frame while the tool is active.</p> <ul> <li>Continuously tracks hand movement.</li> <li>Updates the preview visuals based on new hand position.</li> <li>Some tools (like BrushTool) dynamically add points to a list; others (like ShapeTool or TextTool) update size or orientation in real time.</li> </ul> <p>You may notice that no other method calls update(). This gets to the core of how Unity works behind the scenes. Unity automatically calls <code>Update()</code> every frame on any <code>MonoBehaviour</code><sup>4</sup> script that is both active and <sup>5</sup>. In <code>BrushTool</code>, <code>Update()</code> begins running when <code>StartTool()</code> sets <code>enabled = true</code>, and stops when <code>StopTool()</code> sets it to <code>false</code>.</p>"},{"location":"tool_scripts/#7-stoptool","title":"7. StopTool","text":"<p>csharp<pre><code>public async void StopTool(bool isLeftHand)\n{\n    if (!enabled || isLeftHand != this.isLeftHand) return;\n\n    Vector3 endPos = oldPos.Value;\n    meshPoints.Add(endPos);\n\n    GameObject obj = BrushRenderer.Instance.GenerateMesh(true, meshPoints);\n    ...\n    if (obj != null)\n    {\n        obj.name = \"Brush\";\n        obj.transform.SetParent(brushParent);\n        obj.layer = 7;\n        MeshOutline outline = obj.AddComponent&lt;MeshOutline&gt;();\n        outline.enabled = false;\n        ...\n    }\n\n    PreviewManager.Instance.StopPreview();\n    enabled = false;\n    oldPos = null;\n    meshPoints = null;\n\n    if (c != null &amp;&amp; ClientManager.Instance.connected)\n    {\n        await ClientManager.Instance.SendCommand(c);\n    }\n\n    if (ClientManager.Instance.connected)\n    {\n        Destroy(obj);\n    }\n}\n</code></pre> Called when the user releases the pinch to finalize the interaction.</p> <ul> <li>Ends the preview and commits the final object to the scene.</li> <li>Generates the actual mesh or 3D object (e.g., stroke, shape, text).</li> <li>Applies metadata like color, material, and layer.</li> <li>Sends the result to the server via <code>ClientManager</code> if networking is enabled.</li> <li>Cleans up internal state and deactivates the tool.</li> </ul>"},{"location":"tool_scripts/#8-regenerate","title":"8. Regenerate","text":"<p>csharp<pre><code>public GameObject Regenerate(BrushContainer c)\n{\n    GameObject newObj = BrushRenderer.Instance.GenerateMesh(...);\n\n    if (newObj != null)\n    {\n        newObj.transform.SetParent(brushParent);\n        newObj.name = \"Brush\";\n        ...\n    }\n\n    return newObj;\n}\n</code></pre> Used to recreate a saved object from serialized data. Each tool includes a <code>Regenerate()</code> method that rebuilds a previously created object from its saved data (like a <code>BrushContainer</code>, <code>LineContainer</code>, etc.).</p> <p>This method is used to:</p> <ul> <li>Reconstruct objects when loading a scene</li> <li>Display objects sent over the network from other users</li> <li>Recreate objects during undo/redo</li> <li>Maintain visual and structural consistency between sessions</li> </ul> <p>It creates a new GameObject, configures it based on saved metadata (e.g. mesh shape, color, size), and adds necessary components (like outlines or colliders). This method will become more relevant when we begin to look at how we are saving data and running a server. </p>"},{"location":"tool_scripts/#tool-script-specifics","title":"Tool Script Specifics","text":"<p>This section lists relevant implementation notes specific to each tool file.</p>"},{"location":"tool_scripts/#brush-tool","title":"Brush Tool","text":"<p>BrushTool enables freeform 3D drawing using continuous hand movement. It generates a smoothed spline mesh based on tracked hand positions.</p> <p>Key behaviors and implementation details:</p> <ul> <li><code>granularity</code> controls how often new points are added. Lower values result in smoother strokes but impact performance and network bandwidth.</li> <li>Points are collected and stored in <code>meshPoints</code> in <code>Update()</code>, and only added when the user moves beyond <code>distanceLeft</code>.</li> <li>When a stroke is finalized in <code>StopTool()</code>, it is:<ul> <li>Passed to <code>BrushRenderer</code> to generate a mesh.</li> <li>Serialized into a <code>BrushContainer</code>.</li> <li>Sent to the server (if connected).</li> <li>Destroyed locally (the server version will be redrawn).</li> </ul> </li> <li>The object is named <code>\"Brush\"</code> and added to the <code>\"Brush Tool\"</code> parent object.</li> <li>Uses layer 7 for brush strokes (<code>Settings.LAYER_BRUSH</code>).</li> <li><code>Regenerate()</code> is used to rebuild the stroke from a <code>BrushContainer</code>, typically on scene load or from server data.</li> </ul> <p>We will elaborate more on <code>BrushRenderer</code> and <code>BrushContainer</code> later.</p>"},{"location":"tool_scripts/#line-tool","title":"Line Tool","text":"<p>LineTool is nearly identical in structure to BrushTool, but is used to create a single straight line between pinch start and release points.</p> <p>Key differences from BrushTool:</p> <ul> <li>The <code>meshPoints</code> list always contains just two positions: start and end.</li> <li>No distance tracking or granularity needed \u2014 it simply connects the two points.</li> <li>The mesh is generated without smoothing (<code>loop: false</code>, <code>smoothnessThreshold: -1</code>).</li> <li>The object is named <code>\"Line\"</code> and added to the <code>\"Line Tool\"</code> parent object.</li> <li>Uses a different layer (typically <code>Settings.LAYER_LINE</code>).</li> <li>Regeneration follows the same container-based pattern (<code>LineContainer</code>), and restores the line\u2019s mesh and transform.</li> </ul>"},{"location":"tool_scripts/#text-tool","title":"Text Tool","text":"<p>TextTool allows users to place a block of 3D text in space by pinching and dragging to set size and position.</p> <p>Key implementation details:</p> <ul> <li>Text content is pulled from <code>ButtonManager.Instance.textToolField.text</code>, or falls back to <code>defaultText</code>.</li> <li>Text is rendered using a <code>TextMeshPro</code> component, which supports dynamic font sizing.</li> <li>A transparent outline is created using a child GameObject from <code>OutlineGenerator.GenerateOutline()</code>.</li> <li>The final text is wrapped in a box collider and registered as interactable.</li> <li>Objects are given layer 10 (<code>Settings.LAYER_TEXT</code>) and parented under <code>\"Text Tool\"</code>.</li> </ul>"},{"location":"tool_scripts/#image-tool","title":"Image Tool","text":"<p>ImageTool fetches 2D images from Unsplash using their API and lets users place them in the scene.</p> <p>Unique logic:</p> <ul> <li>Uses <code>UnityWebRequest</code> to retrieve image data asynchronously.</li> <li>Displays a scrollable UI list of thumbnails, each of which can be clicked to place an image.</li> <li>Placed images are interactive, with <code>ObjectManipulator</code> and drag-handles enabled.</li> <li>Textures are applied directly to a <code>RawImage</code> or Unity <code>Renderer</code>.</li> </ul> <p>Note: This tool does not use pinch gestures or <code>StartTool/StopTool</code> like the others. It\u2019s UI-driven.</p>"},{"location":"tool_scripts/#object-tool","title":"Object Tool","text":"<p>ObjectTool lets users choose from a predefined list of 3D prefabs and place them into the AR scene.</p> <p>Implementation notes:</p> <ul> <li>Prefabs are listed in the <code>localObjects</code> list and displayed using a scroll-down UI menu.</li> <li>Selecting an object instantiates it in front of the user and enables manipulation (<code>ObjectManipulator</code>, <code>BoundsControl</code>).</li> <li>Objects are named according to their prefab and not automatically serialized or networked (unless handled elsewhere).</li> <li>The UI must be manually hooked up in the Unity Inspector (i.e. assign the scroll menu, object prefab, etc.).</li> </ul> <ol> <li> <p>A serialized private variable shows it's value on the Unity Inspector. You can easily change the value like public variable. But nothign can access this value from another script or places.\u00a0\u21a9</p> </li> <li> <p>Vector3 is a data structure used to represent a point in 3D space using 3 float values: x, y, and z. The question mark after indicates that the variable can have a value of null.\u00a0\u21a9</p> </li> <li> <p>One of the most fundamental components in Unity game design. Its a component that defines an objects position, rotation, and scale.  It also manages parent-child hierarchy, where children move, scale, and rotate relative to their parent.\u00a0\u21a9</p> </li> <li> <p>A <code>MonoBehaviour</code> script is the base class that all scripts inherit from if you want them to: be attached to GameObjects and respond to Unity's lifecycle events like <code>Start()</code>, <code>Update()</code>, <code>Awake()</code>, etc. In the specific case of <code>BrushTool</code>, it becomes a unity component you can attach to objects in the scene.\u00a0\u21a9</p> </li> <li> <p><code>enabled</code> is a built-in property from <code>MonoBehaviour</code> that determines whether Unity will call runtime methods like <code>Update()</code> for this script. In tool scripts like <code>BrushTool</code>, <code>enabled</code> is used to: Start tracking input when <code>StartTool()</code> is called (<code>enabled = true</code>) and Stop tracking and finalizing the stroke when <code>StopTool()</code> is called (<code>enabled = false</code>). You don\u2019t need to declare this variable \u2014 it comes from Unity\u2019s MonoBehaviour system.\u00a0\u21a9</p> </li> </ol>"}]}